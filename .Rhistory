The symbol `;` allows to put several instructions on the same line (some will find it ugly though).
It is not necessary to use a symbol to end a line.
```{r}
a<-1
b=2; a+b
```
Here is how to print a nice result.
```{r}
print(paste("a is equal to",a,"and b is equal to",b,"so a+b is equal to",a+b))
```
The list of all declared variables is provided by the command `ls()`.
```{r}
ls()
```
It is often useful to remove all the declared varables, at the beginning of a script for example.
```{r}
rm(list=ls()) # Removes all existing variables
a
```
## 2. Vectors
To create a vector from a finite number of variables, use `c()`.
```{r}
my_vector = c(1, 4, 8)
my_vector
```
```{r}
my_second_vector = c()
my_second_vector[1] = 3
my_second_vector[2] = 1
my_second_vector
```
Some other operators allowing to construct vectors.
```{r}
repeated_ones_and_twos = rep(c(1,2),5) # A vector with the sequence 1, 2 repeated 5 times
consecutive_integers = 1:10 # A vector with the integers from 1 to 10
consecutive_numbers = seq(from=0, to=3, length=10) # A vector of 10 real numbers linearly distributed between 0 and 3
```
The command to access the elements of the vector are as follows.
```{r}
my_vector[1] # Access to the first element
my_vector[0] # Notice that indices start at 1
```
You may access and modify a subvector as follows.
```{r}
big_vector = seq(from=0,to=3,length=10) # A vector with 10 cells
small_vector = big_vector[2:5] # The subvector with coordinates between 2 and 5
big_vector
small_vector
```
Other useful commands related to vectors.
```{r}
l=length(my_vector) # To know the length of a vector
s=sum(my_vector) # Sum of the coordinates
m=mean(my_vector) # Mean of the coordinates
l; s; m; s/l;
```
Most functions and operations applied to vector coefficient by coefficient.
```{r}
my_vector
my_vector+1
2^my_vector
```
## 3. Plots
In this paragraph, we want to plot the curves $y_1 = 1+\cos(x)\exp(-x)$ and $y_2 = 1+\sin(x)\exp(-x)$ for $x$ between $0$ and $2\pi$.
We first use the command `seq` to create a vector of values of $x$.
Notice that $\pi$ is just called `pi`.
```{r}
x = seq(from=0,to=2*pi,length=50)
x
```
We now create vectors for the values of $y_1$ and $y_2$, using direct operations on vectors.
```{r}
y1 = 1 + cos(x)*exp(-x)
y2 = 1 + sin(x)*exp(-x)
```
We are ready to plot $y_1$ as a function of $x$.
```{r}
plot(x,y1)
```
*Exercise:* using the help of the function `plot()`, change the script above to plot a continuous red line rather than black points.
```{r}
# Put your code here!
plot(x,y1, type="l", col=2)
?plot
```
To add a second plot on the same figure, we use the command `lines()`.
```{r}
plot(x,y1,type="l",col="red")
lines(x,y2,type="l",col="blue")
```
# II. Random variables and histogram
## 1. Random variable generation
The following command generates a vector of $n$ independent uniform random variables in $[0,1]$.
```{r}
n = 100
vect_unif = runif(n)
```
*Exercise:* using the function `mean` seen above and coefficient by coefficient operations, compute the variance of the vector `vect_unif`.
```{r}
# Put your code here!
var<- mean((vect_unif-mean(vect_unif))^2)
var(vect_unif)
Compare your result with what you get using the function `var`.
```{r}
var(vect_unif)
```
## 2. Histogram
We plot two histograms, with 20 bins each, of the sample `vect_unif`. What is the difference between the two pictures?
```{r}
hist(vect_unif,breaks=20,freq=T)
```
```{r}
hist(vect_unif,breaks=20,freq=F)
```
# III. Functions and programming commands
Here are three functions, which use the commands `if`, `for`, and `while`.
What do they do?
```{r}
FirstMysteryFunction = function(p) { # p must be between 0 and 1
U = runif(1)
if (U <= p) {
return(1)
} else {
return(0)
}
}
X=FirstMysteryFunction(.5)
X
```
```{r}
SecondMysteryFunction = function(n,p) { # n must be an integer, p must be between 0 and 1
s = 0
for (i in 1:n) {
s = s + FirstMysteryFunction(p)
}
return(s)
}
S=SecondMysteryFunction(10,.5)
S
```
```{r}
ThirdMysteryFunction = function(p) { # p must be between 0 (strictly) and 1
i = 1
while(FirstMysteryFunction(p)==0) {
i=i+1
}
return(i)
}
T=ThirdMysteryFunction(.01)
T
```
# IV. Convergences
## 1. Law of Large Numbers
Let $(X_i)_{i \geq 1}$ be a sequence of iid $\mathcal{N}(0,1)$ random variables, with parameter $1$. We plot the curve of the function $n \mapsto \bar{X}_n$ for $n \in \{1, \ldots, 5000\}$, superposed with the horizontal line with height $y=0$.
```{r}
N = 5000 # Size of the sample
x = rnorm(N) # Sample of N standard Gaussian variables
xbar = c() # The vector xbar will eventually contain the values of \bar{X}_n
for (n in 1:N) {
xbar[n] = mean(x[1:n])
}
plot(1:N,xbar,type="l")
abline(h=0,col="red")
```
*Exercise:* Modify the code to plot the same graph with Cauchy random variables. What do you observe?
```{r}
# Put your code here!
N = 5000 # Size of the sample
x = rcauchy(N) # Sample of N standard Gaussian variables
xbar = c() # The vector xbar will eventually contain the values of \bar{X}_n
for (n in 1:N) {
xbar[n] = mean(x[1:n])
}
plot(1:N,xbar,type="l")
abline(h=0,col="red")
## 2. Central Limit Theorem
Let $Z_n$ be the random variable defined by $$Z_n = \sqrt{n}\left(\bar{X}_n - 1\right),$$ where $(X_i)_{1 \leq i \leq n}$ is a sequence of Exponential random variables with parameter $1$.
*Exercise:* Create a sample of $M=5000$ independent copies of $Z_n$, and plot its histogram superposed with the density of the standard Gaussian distribution. Compare the graphs obtained for $n=10$ and $n=100$. What do you conclude?
```{r}
# Put your code here!
M = 5000 # Size of the sample
x = rexp(N) # Sample of N standard Gaussian variables
xbar = c() # The vector xbar will eventually contain the values of \bar{X}_n
for (n in 1:N) {
xbar[n] = mean(x[1:n])
}
Z10=sqrt(10)*(xbar-1)
Z100=sqrt(100)*(xbar-1)
xd<-seq(-4,+4,by=0.02)
hist(vect_unif,breaks=20,freq=F)
curve(dnorm(xd), add=TRUE)
a<-1
print(paste("a is equal to",a,"and b is equal to",b,"so a+b is equal to",a+b))
hist(vect_unif,breaks=20,freq=F)
curve(dnorm,xd, add=TRUE)
N = 5000 # Size of the sample
x = rnorm(N) # Sample of N standard Gaussian variables
xbar = c() # The vector xbar will eventually contain the values of \bar{X}_n
for (n in 1:N) {
xbar[n] = mean(x[1:n])
}
plot(1:N,xbar,type="l")
abline(h=0,col="red")
# Put your code here!
N = 5000 # Size of the sample
x = rcauchy(N) # Sample of N standard Gaussian variables
xbar = c() # The vector xbar will eventually contain the values of \bar{X}_n
for (n in 1:N) {
xbar[n] = mean(x[1:n])
}
plot(1:N,xbar,type="l")
abline(h=0,col="red")
## 2. Central Limit Theorem
?dnorm
plot(function(x) dnorm(x), -60, 50, main = " Normal density ")
?student
?dt
line(function(x) dt(x,1), -60, 50, main = " t(1)")
line(function(x) dt(x,1), -60, 50, main = " t1")
plot(function(x) dnorm(x), -60, 50, main = " Normal density ")
line(function(x) dt(x,1), -60, 50, main = " t1")
line(function(x) dt(x,1), -60, 50)
plot(function(x) dnorm(x), -60, 50, main = " Normal density ")
line(function(x) dt(x,1), -60, 50)
plot(function(x) dnorm(x), -60, 50, main = " Normal density ")
line(function(x) dt(x,df=1), -60, 50)
?dnorm
plot(function(x) dnorm(x), -60, 50, main = " Normal density ")
lines(function(x) dt(x,df=1), -60, 50)
x<- seq(-60,50)
x<- seq(-60,50, 1000)
x<- seq(-60,50, length= 1000)
y= dnorm(x)
plot(x,y)
w= dt(x)
w= dt(x, df =1)
lines(x,w)
w2=dt (x, df = 5)
lines(x,wé, colors())
?lines
lines(x,wé, col = 4)
lines(x,w2, col = 4)
w3 = dt(x, df =10)
lines(x,w3, col = 5)
x<- seq(-20,20, length= 1000)
y= dnorm(x)
w= dt(x, df =1)
w2=dt (x, df = 5)
w3 = dt(x, df =10)
plot(x,y)
lines(x,w)
lines(x,w2, col = 4)
lines(x,w3, col = 5)
?dnorm
x<- seq(-10,10, length= 1000)
y= dnorm(x)
w= dt(x, df =1)
w2=dt (x, df = 5)
w3 = dt(x, df =10)
plot(x,y)
lines(x,w)
lines(x,w2, col = 4)
lines(x,w3, col = 8)
?dnorm
x<- seq(-5,5, length= 1000)
y= dnorm(x)
w= dt(x, df =1)
w2=dt (x, df = 5)
w3 = dt(x, df =10)
plot(x,y)
lines(x,w)
lines(x,w2, col = 4)
lines(x,w3, col = 8)
?lines
rm(list=ls())
n = 30
mu = 0
sigma = 1
x = rnorm(n,mean=mu,sd=sigma)
mu_0 = .2
p_val = 2*(1-pnorm(sqrt(n/sigma^2)*abs(mean(x)-mu_0)))
p_val
?pchisq
sigma_0 = .8
alpha = 0.05
q_alpha = qchisq(p = 1-alpha, df = n-1)
Value_chi_2 = 1/sigma_0^2*var(x)
# Your code here
mu_0 = .01
# Two-sided Z-test for H_0 = {\mu = \mu_0}, H_1 = {\mu \not= \mu_0}
t_test_1 = t.test(x, alternative="two.sided", mu=mu_0)
t_test_1
print(t_test_1$p.value)
# H_1 = {\mu < \mu_0}
t_test_2 = t.test(x, alternative="less", mu=mu_0)
print(t_test_2$p.value)
# H_1 = {\mu > \mu_0}
t_test_3 = t.test(x, alternative="greater", mu=mu_0)
print(t_test_3$p.value)
# First funny identity
t_test_2$p.value / t_test_1$p.value
# Second funny identity
t_test_2$p.value + t_test_3$p.value
heart_rates = c(80,74,73,72,78,75,70,74,69)
hours_of_sleep = c(7.2,8.7,5.4,6.1,5.6,6.7,5.9,6.3,7,4.2)
n_s = 15
mu_s = -.1
x_s = rnorm(n_s,mu_s,sigma)
f_test = var.test(x,x_s)
f_test
t_test_two_samples = t.test(x,x_s,alternative="two.sided",var.equal=T)
t_test_two_samples
grades_imi = c(8.5,10,10,10,11,11.5,11.5,12,12,12,
12,12.5,12.5,12.5,12.5,13,13,13,13,13,
13,13,13,13.5,14,14,14,14,14,14,
14.5,14.5,14.5,15,15,15.5,15.5,15.5,15.5,15.5,
16,16,16,16,16,16,16.5,16.5,16.5,16.5,
18.5,18.5,19,19)
grades_segf = c(3.5,10,10,10.5,10.5,11,11,11,11.5,11.5,
12.5,12.5,13.5,13.5,13.5,14,14.5,15,15.5,15.5,
15.5,16,16.5,17,17,17.5)
print(mean(grades_imi))
print(mean(grades_segf))
print(sd(grades_imi))
print(sd(grades_segf))
# Your code here
# Your code here
# Your code here
# Load the mtcars dataset
data(mtcars)
mtcars
# Fit linear regression model
model = lm(qsec ~ mpg + hp, data = mtcars)
# Summary of the regression model
summary(model)
heart_rates = c(80,74,73,72,78,75,70,74,69)
pvalue_heart = 1-pnorm(mean(heart_rates), mean = 71, sd = 4)
heart_rates = c(80,74,73,72,78,75,70,74,69)
pvalue_heart = 1-pnorm(mean(heart_rates), mean = 71, sd = 4/9)
hours_of_sleep = c(7.2,8.7,5.4,6.1,5.6,6.7,5.9,6.3,7,4.2)
mu_0_sleep = 6
# Two-sided Z-test for H_0 = {\mu = \mu_0}, H_1 = {\mu \not= \mu_0}
t_test_1 = t.test(hours_of_sleep, alternative="two.sided", mu=mu_0_sleep)
hours_of_sleep = c(7.2,8.7,5.4,6.1,5.6,6.7,5.9,6.3,7,4.2)
mu_0_sleep = 6
# Two-sided Z-test for H_0 = {\mu = \mu_0}, H_1 = {\mu \not= \mu_0}
t_test_1_sleep = t.test(hours_of_sleep, alternative="two.sided", mu=mu_0_sleep)
t_test_1_sleep
n_s = 15
mu_s = -.1
x_s = rnorm(n_s,mu_s,sigma)
f_test = var.test(x,x_s)
f_test
t_test_two_samples = t.test(x,x_s,alternative="two.sided",var.equal=T)
t_test_two_samples
# Your code here
f_test = var.test(grades_imi,grades_segf)
f_test
# Your code here
t_test_two_samples = t.test(x,x_s,alternative="two.sided",var.equal=T)
t_test_two_samples
# Your code here
t_test_two_samples_garde_1 = t.test(grades_imi,grades_segf,alternative="two.sided",var.equal=T)
t_test_two_samples_grade_1
# Your code here
t_test_two_samples_grade_1 = t.test(grades_imi,grades_segf,alternative="two.sided",var.equal=T)
t_test_two_samples_grade_1
t_test_two_samples_grade_2 = t.test(grades_imi,grades_segf,alternative="two.sided",var.equal=F)
t_test_two_samples_grade_2
# Your code here
expect_gaussian(grades_imi)
# Load the mtcars dataset
data(mtcars)
mtcars
# Summary of the regression model
pnorm(qnorm(0.95)-25*log(1.5))
# Summary of the regression model
pnorm(qnorm(0.05)-25*log(1.5))
library(ggplot2)        # plotting & data
library(dplyr)          # data manipulation
library(tidyr)          # data re-shaping
library(magrittr)       # pipe operator
library(gridExtra)      # provides side-by-side plotting
head(midwest)
f=midwest
View(f)
p1 <- ggplot(midwest, aes(percollege)) +
geom_histogram(fill = "white", color = "grey30")
p2 <- ggplot(midwest, aes(percollege)) +
geom_histogram(fill = "white", color = "grey30") +
scale_x_log10()
grid.arrange(p1, p2, ncol = 2)
library(ggplot2)        # plotting & data
library(dplyr)          # data manipulation
library(tidyr)          # data re-shaping
library(magrittr)       # pipe operator
library(gridExtra)
df <- midwest %>%
filter(state == "OH" | state == "MI") %>%
select(state, percollege)
View(df)
chisq.test(df)
chisq.test(df)
?chisq.test
chisq.test(df)
chisq.test(df%>% filter(state == "MI") %>% .$percollege, df%>% filter(state == "HO") %>% .$percollege)
chisq.test(df%>% filter(state == "MI") %>% .$percollege, df%>% filter(state == "HO") %>% .$percollege, rescale.p =  TRUE)
data <- read.csv(file.choose())
View(data)
plot(data)
data <- read.csv(file.choose())
plot(data)
library(RSQLite)
setwd("C:/Users/33782/OneDrive/Documents/ProjetIMI")
conn <- dbConnect(RSQLite::SQLite(), "time_series_energy_60min.sqlite3")
#
dbListTables(conn)
time_series_60min <- dbGetQuery(conn, "SELECT * FROM  time_series_60min_singleindex")
# summary(time_series_60min)
dbDisconnect(conn)
View(time_series_60min)
time_series_60min$DE_solar_profile
DE_solar_profile = time_series_60min$DE_solar_profile
De_solar_capacity = time_series_60min$DE_solar_capacity
DE_solar_capacity = time_series_60min$DE_solar_capacity
DE_solar_generation_product = DE_solar_capacity*DE_solar_profile
DE_solar_generation_product
DE_solar_actual_consumption = time_series_60min$DE_solar_generation_actual
DE_solar_generation_product -DE_solar_actual_consumption
plot(DE_solar_generation_product -DE_solar_actual_consumption)
plot((DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
DE_solar_actual_consumption
5/0
hist(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(DE_solar_capacity)
DE_wind_profile = time_series_60min$DE_wind_profile
DE_wind_capacity = time_series_60min$DE_wind_capacity
plot(DE_wind_capacity)
par(mfrow=c(2,2))
plot(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
hist(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(DE_solar_capacity)
plot(DE_wind_capacity)
par(mfrow=c(3,2))
plot(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
hist(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(DE_solar_capacity)
plot(DE_wind_capacity)
plot(DE_solar_profile)
plot(DE_wind_profile)
mean_solar_capacity = mean(DE_solar_capacity)
mean_solar_capacity = mean(DE_solar_capacity, na.action = na.pass)
mean_solar_capacity = mean(DE_solar_capacity, na.action = na.pass)
mean_solar_capacity = mean(DE_solar_capacity, na.action = na.omit)
mean_solar_capacity = mean(DE_solar_capacity, na.action = na.exclude)
mean_solar_capacity = mean(DE_solar_capacity,na.rm = TRUE)
mean_wind_capacity = mean(DE_wind_capacity,na.rm = TRUE)
DE_solar_generation_product = mean_solar_capacity*DE_solar_profile
DE_wind_generation_product = mean_wind_capacity*DE_wind_profile
par(mfrow=c(4,2))
plot(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
hist(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(DE_solar_capacity)
plot(DE_wind_capacity)
plot(DE_solar_profile)
plot(DE_wind_profile)
mean_solar_capacity = mean(DE_solar_capacity,na.rm = TRUE)
mean_wind_capacity = mean(DE_wind_capacity,na.rm = TRUE)
DE_solar_generation_product = mean_solar_capacity*DE_solar_profile
DE_wind_generation_product = mean_wind_capacity*DE_wind_profile
plot(DE_solar_generation_product)
plot(DE_wind_generation_product)
plot(data)
par(mfrow=c(4,2))
plot(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
hist(abs(DE_solar_generation_product -DE_solar_actual_consumption)/DE_solar_actual_consumption)
plot(DE_solar_capacity)
plot(DE_wind_capacity)
plot(DE_solar_profile)
plot(DE_wind_profile)
mean_solar_capacity = mean(DE_solar_capacity,na.rm = TRUE)
mean_wind_capacity = mean(DE_wind_capacity,na.rm = TRUE)
DE_solar_generation_product = mean_solar_capacity*DE_solar_profile
DE_wind_generation_product = mean_wind_capacity*DE_wind_profile
plot(DE_solar_generation_product)
plot(DE_wind_generation_product)
library(rpart)
library(rpart.plot)
model <-rpart(GH~., data = data)
GH<-data$Optimal_Cost
model <-rpart(GH~., data = data)
prp(model)
model <-rpart(Optimal_Cost~., data = data)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =  0.001)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =  0.0001)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =  0.00001)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =  0.0000001)
prp(model)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =  0.00000000001)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =9)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =0.9)
prp(model)
model <-rpart(Optimal_Cost~., data = data, cp =0.09)
prp(model)
